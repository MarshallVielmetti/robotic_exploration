/**
 * @file ShortTermPathPlanner.cpp
 *
 * @brief This file implements the ShortTermPathPlanner class defined in
 * ShortTermPathPlanner.hpp.
 */

#include "exploration_sim_planner/short_term_planner/ShortTermPathPlanner.hpp"

#include <Eigen/Dense>
#include <iterator>
#include <optional>
#include <vector>

#include "exploration_sim_planner/util/AStar.hpp"

#define SAFETY_THRESHOLD 3  // 3 cells

std::vector<Eigen::Vector2d> ShortTermPathPlanner::fit_smoothed_path(
    const Eigen::MatrixXd& esdf,
    const std::vector<Eigen::Vector2d>& global_path,
    const Eigen::Vector2d& current_position) {
  // Only accept first 5 nodes along the global path
  std::vector<Eigen::Vector2d> shortened_path;
  shortened_path.reserve(5);

  for (size_t i = 0; i < 5 && i < global_path.size(); i++) {
    shortened_path.push_back(global_path[i]);
  }

  // Fit an A* path to the shortened path
  auto astar_path = fit_astar(esdf, shortened_path, current_position);

  if (!astar_path.has_value()) {
    return {};
  }

  // Fit a cubic b-spline to the A* path
  // auto cubic_spline = fit_cubic_bspline(esdf, astar_path.value());

  // TODO: Potentially incorporate an optimization layer here to
  // improve the b-spline by descending the ESDF

  // Sample points long the path -- maybe proportional to the total length of
  // the path?
  // auto path = sample_path(cubic_spline, 100);
  std::vector<Eigen::Vector2d> path;

  std::transform(
      astar_path.value().begin(), astar_path.value().end(), path.begin(),
      [](const Eigen::Vector2i& point) { return point.cast<double>(); });

  return path;
}

std::optional<std::vector<Eigen::Vector2i>> ShortTermPathPlanner::fit_astar(
    const Eigen::MatrixXd& esdf,
    const std::vector<Eigen::Vector2d>& global_path,
    const Eigen::Vector2d& current_position) {
  using EsdfAstar = AStar<Eigen::Vector2i, double>;

  // Path generated by astar
  std::vector<Eigen::Vector2i> astar_path;

  // Add the starting position to a vector of waypoints and convert to ints
  std::vector<Eigen::Vector2i> waypoints;
  waypoints.push_back(current_position.cast<int>());
  std::transform(
      global_path.begin(), global_path.end(), std::back_inserter(waypoints),
      [](const Eigen::Vector2d& point) { return point.cast<int>(); });

  // Define the 8-connected offsets
  static const std::array<Eigen::Vector2i, 8> offsets{
      Eigen::Vector2i(-1, 0), Eigen::Vector2i(1, 0),   Eigen::Vector2i(0, -1),
      Eigen::Vector2i(0, 1),  Eigen::Vector2i(-1, -1), Eigen::Vector2i(-1, 1),
      Eigen::Vector2i(1, -1), Eigen::Vector2i(1, 1)};

  EsdfAstar::NodeComparator comp = [](const EsdfAstar::Node& a,
                                      const EsdfAstar::Node& b) {
    return a.cost > b.cost;
  };

  EsdfAstar::GetNeighbors get_neighbor = [&esdf](const Eigen::Vector2i& cell) {
    std::vector<EsdfAstar::Node> neighbors;

    for (auto& offset : offsets) {
      Eigen::Vector2i neighbor = cell + offset;

      if (neighbor.x() < 0 || neighbor.x() >= esdf.cols() || neighbor.y() < 0 ||
          neighbor.y() >= esdf.rows()) {
        continue;
      }

      double esdf_value = esdf(neighbor.y(), neighbor.x());

      // only consider values with an ESDF value greater than some safety
      // threshold
      if (esdf_value < SAFETY_THRESHOLD) {
        continue;
      }

      double cost = offset.norm() == 1 ? 1.0 : 1.414;

      neighbors.push_back(EsdfAstar::Node{neighbor, cost});
    }

    return neighbors;
  };

  EsdfAstar::Heuristic h = [](const Eigen::Vector2i& a,
                              const Eigen::Vector2i& b) {
    return (a - b).norm();
  };

  // loop through every pair of waypoints
  EsdfAstar astar;
  for (size_t i = 0; i < waypoints.size() - 1; i++) {
    auto start_node = waypoints[i];
    auto end_node = waypoints[i + 1];

    auto result = astar.find_path(start_node, end_node, get_neighbor, h, comp);

    if (!result.has_value()) {
      return std::nullopt;
    }

    // Extract results if successful
    auto [path, cost] = result.value();

    // Append the path to the astar path -- don't add the last point
    astar_path.insert(astar_path.end(), path.begin(), path.end() - 1);
  }

  // Add the last point (not added in for loop)
  astar_path.push_back(waypoints.back());
  return astar_path;
}

// CubicBSpline ShortTermPathPlanner::fit_cubic_bspline(
//     const Eigen::MatrixXd& esdf,
//     const std::vector<Eigen::Vector2i>& astar_path) {}
