/**
 * @file ShortTermPathPlanner.cpp
 *
 * @brief This file implements the ShortTermPathPlanner class defined in
 * ShortTermPathPlanner.hpp.
 */

#include "exploration_sim_planner/short_term_planner/ShortTermPathPlanner.hpp"

#include <Eigen/Dense>
#include <iostream>
#include <iterator>
#include <optional>
#include <vector>

#include "Eigen/src/Core/Matrix.h"
#include "exploration_sim_planner/util/AStar.hpp"
#include "exploration_sim_planner/util/BSplineUtil.hpp"
#include "exploration_sim_planner/util/EsdfUtil.hpp"

#define SAFETY_THRESHOLD 3  // 3 cells

std::vector<Eigen::Vector2d> ShortTermPathPlanner::fit_smoothed_path(const Eigen::MatrixXd& ogm,
                                                                     const std::vector<Eigen::Vector2d>& global_path) {
  // Plan path of a maximum length of 80 cells (40 meters)
  auto shortened_path = shorten_path(global_path, 80);

  // Get an esdf from the ogm
  auto esdf = EsdfUtil::computeEsdf(ogm, 20);

  // Fit an A* path to the shortened path
  auto astar_path = fit_astar(esdf, shortened_path);

  // If unable to find a path, return an empty path
  if (!astar_path.has_value()) {
    return {};
  }

  // Fit a cubic b-spline to the A* path
  auto cubic_spline = fit_cubic_bspline(esdf, astar_path.value());

  // Sample 100 points along the spline
  return cubic_spline.sample(100);
}

std::optional<std::vector<Eigen::Vector2i>> ShortTermPathPlanner::fit_astar(
    const Eigen::MatrixXd& esdf, const std::vector<Eigen::Vector2d>& global_path) {
  using EsdfAstar = AStar<Eigen::Vector2i, double>;

  // Path generated by astar
  std::vector<Eigen::Vector2i> astar_path;

  // Add the starting position to a vector of waypoints and convert to ints
  std::vector<Eigen::Vector2i> waypoints;
  std::transform(global_path.begin(), global_path.end(), std::back_inserter(waypoints),
                 [](const Eigen::Vector2d& point) { return point.cast<int>(); });

  // Define the 8-connected offsets
  static const std::array<Eigen::Vector2i, 8> offsets{
      Eigen::Vector2i(-1, 0),  Eigen::Vector2i(1, 0),  Eigen::Vector2i(0, -1), Eigen::Vector2i(0, 1),
      Eigen::Vector2i(-1, -1), Eigen::Vector2i(-1, 1), Eigen::Vector2i(1, -1), Eigen::Vector2i(1, 1)};

  EsdfAstar::NodeComparator comp = [](const EsdfAstar::Node& a, const EsdfAstar::Node& b) { return a.cost > b.cost; };

  EsdfAstar::GetNeighbors get_neighbor = [&esdf](const Eigen::Vector2i& cell) {
    std::vector<EsdfAstar::Node> neighbors;

    for (auto& offset : offsets) {
      Eigen::Vector2i neighbor = cell + offset;

      if (neighbor.x() < 0 || neighbor.x() >= esdf.cols() || neighbor.y() < 0 || neighbor.y() >= esdf.rows()) {
        continue;
      }

      double esdf_value = esdf(neighbor.y(), neighbor.x());

      // ONLY CONSIDER FREE CELLS -- TODO REPLACE WITH ESDF
      if (esdf_value <= SAFETY_THRESHOLD) {
        continue;
      }

      double incremental_cost = offset.cast<double>().norm();

      neighbors.push_back(EsdfAstar::Node{neighbor, incremental_cost});
    }

    return neighbors;
  };

  EsdfAstar::Heuristic h = [](const Eigen::Vector2i& a, const Eigen::Vector2i& b) { return (a - b).norm(); };

  // loop through every pair of waypoints
  EsdfAstar astar;
  for (size_t i = 0; i < waypoints.size() - 1; i++) {
    auto start_node = waypoints[i];
    auto end_node = waypoints[i + 1];

    auto result = astar.find_path(start_node, end_node, get_neighbor, h, comp);

    if (!result.has_value()) {
      return std::nullopt;
    }

    // Extract results if successful
    auto [path, cost] = result.value();

    // Path is empty... so who cares
    if (path.empty() || path.size() == 1) {
      continue;
    }

    // Append the path to the astar path -- don't add the last point
    astar_path.insert(astar_path.end(), path.begin(), path.end() - 1);
  }

  // Add the last point (not added in for loop)
  if (waypoints.size() > 1) {
    astar_path.push_back(waypoints.back());
  }

  return astar_path;
}

// TODO -- Need path in map frame...
bool ShortTermPathPlanner::check_path_safety(const Eigen::MatrixXd& esdf, const nav_msgs::msg::Path& path) {
  // for (const auto& pose : path.poses) {
  //   Eigen::Vector2d point(pose.pose.position.x, pose.pose.position.y);
  //   auto cell = point.cast<int>();

  //   // Check if the cell is occupied
  //   if (esdf(cell.y(), cell.x()) == 100) {
  //     return false;
  //   }
  // }

  if (path.poses.empty() || esdf.rows() == 0 || esdf.cols() == 0) {
    return false;
  }

  return true;
}

BSplineUtil::CubicBSpline ShortTermPathPlanner::fit_cubic_bspline(const Eigen::MatrixXd& esdf,
                                                                  const std::vector<Eigen::Vector2i>& astar_path) {
  std::vector<Eigen::Vector2d> path;
  std::transform(astar_path.begin(), astar_path.end(), std::back_inserter(path),
                 [](const Eigen::Vector2i& point) { return point.cast<double>(); });

  // Initial B-spline fitting with moderate smoothness
  auto spline = BSplineUtil::fitCubicBSpline(path, 0.8);

  // Optimize the spline using gradient descent
  // Balance safety (0.7) vs path length (0.3)
  auto optimized_spline = BSplineUtil::optimizeSpline(spline, esdf, 0.7, 0.3, 0.05, 50);

  // If optimization failed to produce a safe path, fall back to the original
  // spline
  if (!BSplineUtil::checkSplineSafety(esdf, optimized_spline, 2.0)) {
    // Try with less smoothing
    spline = BSplineUtil::fitCubicBSpline(path, 0.1);

    // Try optimization again with higher safety weight
    optimized_spline = BSplineUtil::optimizeSpline(spline, esdf, 0.9, 0.1, 0.03, 100);

    // If still not safe, use minimal smoothing
    if (!BSplineUtil::checkSplineSafety(esdf, optimized_spline, 1.5)) {
      return BSplineUtil::fitCubicBSpline(path, 0.05);
    }
  }

  return optimized_spline;
}

std::vector<Eigen::Vector2d> ShortTermPathPlanner::shorten_path(const std::vector<Eigen::Vector2d>& global_path,
                                                                double max_length) {
  std::vector<Eigen::Vector2d> shortened_path;
  double curr_length = 0.0;

  shortened_path.push_back(global_path.front());

  for (size_t i = 1; i < global_path.size() && curr_length < max_length; i++) {
    curr_length += (global_path[i] - global_path[i - 1]).norm();
    shortened_path.push_back(global_path[i]);
  }

  return shortened_path;
}