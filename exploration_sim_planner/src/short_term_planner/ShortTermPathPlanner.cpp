/**
 * @file ShortTermPathPlanner.cpp
 *
 * @brief This file implements the ShortTermPathPlanner class defined in
 * ShortTermPathPlanner.hpp.
 */

#include "exploration_sim_planner/short_term_planner/ShortTermPathPlanner.hpp"

#include <Eigen/Dense>
#include <cstddef>
#include <iostream>
#include <iterator>
#include <optional>
#include <vector>

#include "Eigen/src/Core/Matrix.h"
#include "exploration_sim_planner/util/AStar.hpp"
#include "exploration_sim_planner/util/BSplineUtil.hpp"
#include "exploration_sim_planner/util/EsdfUtil.hpp"
#include "exploration_sim_planner/util/OmplDubinsPath.hpp"

#define SAFETY_THRESHOLD 1  // 3 cells

std::vector<Eigen::Vector2d> ShortTermPathPlanner::fit_smoothed_path(const Eigen::MatrixXd& ogm,
                                                                     const std::vector<Eigen::Vector2d>& global_path) {
  // Plan path of a maximum length of 80 cells (40 meters)
  auto shortened_path = shorten_path(global_path, 80);

  // Get an esdf from the ogm
  auto esdf = EsdfUtil::computeEsdf(ogm, 20);

  // Fit an A* path to the shortened path
  auto astar_path = fit_astar(esdf, shortened_path);

  // If unable to find a path, return an empty path
  if (!astar_path.has_value()) {
    return {};
  }

  // Fit a cubic b-spline to the A* path
  auto cubic_spline = fit_cubic_bspline(esdf, astar_path.value());

  // Sample 100 points along the spline
  return cubic_spline.sample(100);
}

std::optional<std::vector<Eigen::Vector2i>> ShortTermPathPlanner::fit_astar(
    const Eigen::MatrixXd& esdf, const std::vector<Eigen::Vector2d>& global_path) {
  using EsdfAstar = AStar<Eigen::Vector2i, double>;

  // Path generated by astar
  std::vector<Eigen::Vector2i> astar_path;

  // Add the starting position to a vector of waypoints and convert to ints
  std::vector<Eigen::Vector2i> waypoints;
  std::transform(global_path.begin(), global_path.end(), std::back_inserter(waypoints),
                 [](const Eigen::Vector2d& point) { return point.cast<int>(); });

  // Define the 8-connected offsets
  static const std::array<Eigen::Vector2i, 8> offsets{
      Eigen::Vector2i(-1, 0),  Eigen::Vector2i(1, 0),  Eigen::Vector2i(0, -1), Eigen::Vector2i(0, 1),
      Eigen::Vector2i(-1, -1), Eigen::Vector2i(-1, 1), Eigen::Vector2i(1, -1), Eigen::Vector2i(1, 1)};

  EsdfAstar::NodeComparator comp = [](const EsdfAstar::Node& a, const EsdfAstar::Node& b) { return a.cost > b.cost; };

  EsdfAstar::GetNeighbors get_neighbor = [&esdf](const Eigen::Vector2i& cell) {
    std::vector<EsdfAstar::Node> neighbors;

    for (auto& offset : offsets) {
      Eigen::Vector2i neighbor = cell + offset;

      if (neighbor.x() < 0 || neighbor.x() >= esdf.cols() || neighbor.y() < 0 || neighbor.y() >= esdf.rows()) {
        continue;
      }

      double esdf_value = esdf(neighbor.y(), neighbor.x());

      // ONLY CONSIDER FREE CELLS -- TODO REPLACE WITH ESDF
      if (esdf_value <= SAFETY_THRESHOLD) {
        continue;
      }

      double incremental_cost = offset.cast<double>().norm();

      neighbors.push_back(EsdfAstar::Node{neighbor, incremental_cost});
    }

    return neighbors;
  };

  EsdfAstar::Heuristic h = [](const Eigen::Vector2i& a, const Eigen::Vector2i& b) { return (a - b).norm(); };

  // loop through every pair of waypoints
  EsdfAstar astar;
  for (size_t i = 0; i < waypoints.size() - 1; i++) {
    auto start_node = waypoints[i];
    auto end_node = waypoints[i + 1];

    auto result = astar.find_path(start_node, end_node, get_neighbor, h, comp);

    if (!result.has_value()) {
      // Unable to find a path that goes through all the waypoints
      // so just return what they have so far, unless i = 0
      return std::nullopt;
    }

    // Extract results if successful
    auto [path, cost] = result.value();

    // Path is empty... so who cares
    if (path.empty() || path.size() == 1) {
      continue;
    }

    // Append the path to the astar path -- don't add the last point
    astar_path.insert(astar_path.end(), path.begin(), path.end() - 1);
  }

  // Add the last point (not added in for loop)
  if (waypoints.size() > 1) {
    astar_path.push_back(waypoints.back());
  }

  return astar_path;
}

// TODO -- Need path in map frame...
bool ShortTermPathPlanner::check_path_safety(const Eigen::MatrixXd& esdf, const nav_msgs::msg::Path& path) {
  // for (const auto& pose : path.poses) {
  //   Eigen::Vector2d point(pose.pose.position.x, pose.pose.position.y);
  //   auto cell = point.cast<int>();

  //   // Check if the cell is occupied
  //   if (esdf(cell.y(), cell.x()) == 100) {
  //     return false;
  //   }
  // }

  if (path.poses.empty() || esdf.rows() == 0 || esdf.cols() == 0) {
    return false;
  }

  return true;
}

BSplineUtil::CubicBSpline ShortTermPathPlanner::fit_cubic_bspline(const Eigen::MatrixXd& esdf,
                                                                  const std::vector<Eigen::Vector2i>& astar_path) {
  std::vector<Eigen::Vector2d> path;
  std::transform(astar_path.begin(), astar_path.end(), std::back_inserter(path),
                 [](const Eigen::Vector2i& point) { return point.cast<double>(); });

  // Initial B-spline fitting with moderate smoothness
  auto spline = BSplineUtil::fitCubicBSpline(path, 0.8);
  return spline;

  // Optimize the spline using gradient descent
  // Balance safety (0.7) vs path length (0.3)
  auto optimized_spline = BSplineUtil::optimizeSpline(spline, esdf, 0.7, 0.3, 0.05, 50);

  // If optimization failed to produce a safe path, fall back to the original
  // spline
  if (!BSplineUtil::checkSplineSafety(esdf, optimized_spline, 2.0)) {
    // Try with less smoothing
    spline = BSplineUtil::fitCubicBSpline(path, 0.1);

    // Try optimization again with higher safety weight
    optimized_spline = BSplineUtil::optimizeSpline(spline, esdf, 0.9, 0.1, 0.03, 100);

    // If still not safe, use minimal smoothing
    if (!BSplineUtil::checkSplineSafety(esdf, optimized_spline, 1.5)) {
      return BSplineUtil::fitCubicBSpline(path, 0.05);
    }
  }

  return optimized_spline;
}

std::vector<Eigen::Vector2d> ShortTermPathPlanner::shorten_path(const std::vector<Eigen::Vector2d>& global_path,
                                                                double max_length) {
  std::vector<Eigen::Vector2d> shortened_path;
  double curr_length = 0.0;

  shortened_path.push_back(global_path.front());

  for (size_t i = 1; i < global_path.size() && curr_length < max_length; i++) {
    curr_length += (global_path[i] - global_path[i - 1]).norm();
    shortened_path.push_back(global_path[i]);
  }

  return shortened_path;
}

std::optional<std::vector<Eigen::Vector3d>> ShortTermPathPlanner::plan_backup(
    const std::vector<Eigen::Vector2d>& smoothed_path, const std::vector<Eigen::Vector2d>& coverage_path,
    const std::shared_ptr<OgmView>& ogm) {
  auto backup_target = ShortTermPathPlanner::find_next_free_waypoint(ogm, coverage_path);

  if (!backup_target.has_value()) {
    return std::nullopt;
  }

  return compute_backup_dubins(smoothed_path, backup_target.value(), ogm);
}

std::optional<Eigen::Vector2d> ShortTermPathPlanner::find_next_free_waypoint(
    const std::shared_ptr<OgmView>& ogm, const std::vector<Eigen::Vector2d>& coverage_path) {
  Eigen::Vector2d free_node;
  bool found_free = false;

  // Find the first unknown node
  uint32_t unknown_node_index = 0;  // 0 is robot so cant be that
  for (uint32_t i = 0; i < coverage_path.size(); i++) {
    if (ogm->get(coverage_path[i].x(), coverage_path[i].y()) == -1) {
      unknown_node_index = i;
      break;
    }
  }

  if (unknown_node_index == 0) {
    return std::nullopt;
  }

  for (uint32_t i = unknown_node_index; i < coverage_path.size(); i++) {
    if (ogm->get(coverage_path[i].x(), coverage_path[i].y()) == 0) {
      free_node = coverage_path[i];
      found_free = true;
      break;
    }
  }

  if (!found_free) {
    return std::nullopt;
  }

  return free_node;
}

std::optional<std::vector<Eigen::Vector3d>> ShortTermPathPlanner::compute_backup_dubins(
    const std::vector<Eigen::Vector2d>& smoothed_path, const Eigen::Vector2d& backup_point,
    const std::shared_ptr<OgmView>& ogm) {
  size_t into_unknown = 0;

  // Find the index of the first point in the smoothed_path that lies in unknown space
  for (size_t i = 0; i < smoothed_path.size(); i++) {
    auto cell = smoothed_path[i].cast<int>();

    if (ogm->get(cell.x(), cell.y()) == -1) {
      into_unknown = i;
      break;
    }
  }

  if (into_unknown == 0) {
    return std::nullopt;
  }

  Eigen::Vector3d backup_point_3d(backup_point.x(), backup_point.y(), 0.0);

  // Working backwards, compute a dubins path from each point on the path to the backup point
  // If that path lies fully in free space, return it
  for (int i = into_unknown - 1; i >= 0; i = i - 10) {
    auto loc = smoothed_path[i];
    // Convert to vector3d by adding angle between smoothed_path[i] and smoothed_path[i+1]
    Eigen::Vector3d point(loc.x(), loc.y(), 0.0);
    point[2] = atan2(smoothed_path[i + 1].y() - smoothed_path[i].y(), smoothed_path[i + 1].x() - smoothed_path[i].x());

    // Guess that theta for backup point is angle between loc and backup_point
    backup_point_3d[2] = atan2(backup_point.y() - loc.y(), backup_point.x() - loc.x());

    auto dubins_path = OmplDubinsPath::compute_dubins_path(point, backup_point_3d);

    if (!dubins_path.has_value()) {
      continue;
    }

    // Print the path
    std::cout << "PATH PATH\n\n\n" << std::endl;
    for (const auto& point : dubins_path.value()) {
      std::cout << point.transpose() << std::endl;
    }

    // check safety
    if (ShortTermPathPlanner::check_dubins_path_safety(ogm, dubins_path.value())) {
      std::cout << "actually found a backup" << std::endl;
      return dubins_path;
    }
  }

  return std::nullopt;
}

bool ShortTermPathPlanner::check_dubins_path_safety(const std::shared_ptr<OgmView>& ogm,
                                                    const std::vector<Eigen::Vector3d>& path) {
  std::cout << "Unsafe backup" << std::endl;
  for (const auto& point : path) {
    auto cell = point.head<2>().cast<int>();
    if (cell.x() < 0 || cell.x() >= ogm->width() || cell.y() < 0 || cell.y() >= ogm->height()) {
      std::cout << "this fails" << std::endl;
      return false;
    }

    if (ogm->get(cell.x(), cell.y()) != 0) {
      std::cout << "check fails (" << cell.x() << "," << cell.y() << ") " << ogm->get(cell.x(), cell.y()) << "."
                << std::endl;
      return false;
    }
  }

  return true;
}